// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.
package org.usfirst.frc1735.AerialAssist2014.commands;
import edu.wpi.first.wpilibj.command.Command;
import org.usfirst.frc1735.AerialAssist2014.Robot;
/**
 *
 */
public class  CollectDeployWithJoystick extends Command {
    public CollectDeployWithJoystick() {
        // Use requires() here to declare subsystem dependencies
        // eg. requires(chassis);
	
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.collectorDeployer);
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }
    // Called just before this Command runs the first time
    protected void initialize() {
    }
    // Called repeatedly when this Command is scheduled to run
    protected void execute() {
        // We want to move the collector arm UNLESS doing so would exceed our limits
        // Normally, we would use isFinished to handle the end condition of a limit, but
        // because we want the joystick to always remain operational we don't want to halt the command itself.
        // Therefore, we will just condition the activiation on whether the limit has been reached.
        //
        // Algorithm:
        // if we are at max limit, can only retract (conversely, we won't extend).
        // else if we are at min limit, can only extend (conversely, we won't retract).
        // else, let the joystick directly control the unit.
        
        // Implementation
        // Get Joystick value.  Remember that forward is negative, so do the negation here so forward is intuitively positive for the rest of the function...
        double JoyVal = -(Robot.oi.getAccessoryJoystick().getY());
        // We need a deadspot for the joystick in case we are at a limit and the center of the joystick is not really zero...
        // Implemented as a high-pass filter:
        if (Math.abs(JoyVal) < Robot.m_joystickFilter) {JoyVal = 0;}
        // Note that explicitly do NOT use >= and <= 0.  This is because we want zero values to be fed to the motor...
        // This is because IF we clamped the value of the joystick but are not near a limit, we also want stop the motor...
        //boolean reachedLimit = Robot.collectorDeployer.reachedLimit("Min");
        //System.out.print(" Max: ");
        //System.out.print(Robot.collectorDeployer.reachedLimit("Max"));
        //System.out.print(" Min: ");
        //System.out.print(Robot.collectorDeployer.reachedLimit("Min"));
        //System.out.print(" Joy: ");
        //System.out.println(JoyVal);
//        System.out.print("In CollectDeployWithJoystick::execute, limit for deployRetract = ");
//        System.out.println(reachedLimit);
//        System.out.print("In CollectDeployWithJoystick::execute, JoyVal = ");
//        System.out.println(JoyVal);
        if (! ((Robot.collectorDeployer.reachedLimit("Max") && (JoyVal > 0)) ||
               (Robot.collectorDeployer.reachedLimit("Min") && (JoyVal < 0)))) {
            // Open season on using the joystick.  Function assumes forward is positive numbers.
            Robot.collectorDeployer.deployInOut(JoyVal);
        }
        //sanity measure.  If we aren't controlling with the joystick due to a limit, make sure we're not accidentally still sending a motor command from a previous
        else Robot.collectorDeployer.stop();
    }
    // Make this return true when this Command no longer needs to run execute()
    // Joystick control of this unit is expected to be the continuous default unless interrupted, so always return 'false'
    protected boolean isFinished() {
        return false;
    }
    // Called once after isFinished returns true
    protected void end() {
        Robot.collectorDeployer.stop();        
    }
    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    protected void interrupted() {
        end();
    }
}
