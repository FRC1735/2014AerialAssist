// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.
package org.usfirst.frc1735.AerialAssist2014.subsystems;
import org.usfirst.frc1735.AerialAssist2014.RobotMap;
import org.usfirst.frc1735.AerialAssist2014.commands.*;
import edu.wpi.first.wpilibj.*;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import org.usfirst.frc1735.AerialAssist2014.Robot;
/**
 *
 */
public class CollectorDeployer extends Subsystem {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    SpeedController deploymentMotor = RobotMap.collectorDeployerDeploymentMotor;
    SpeedController deploymentMotor2 = RobotMap.collectorDeployerDeploymentMotor2;
    AnalogChannel extensionStringPot = RobotMap.collectorDeployerExtensionStringPot;
    DigitalInput deployLimitOut = RobotMap.collectorDeployerDeployLimitOut;
    DigitalInput deployLimitIn = RobotMap.collectorDeployerDeployLimitIn;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    // Member Variables
    public double m_deployPotMinimum; // Minimum pot reading to be considered fully stowed
    public double m_deployPotMaximum; // Maximum pot reading to be considered fully extended
    public double m_deployPotInterlockMinimum; //Minimum pot reading to be considered out of the way of the shooter
    
    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        setDefaultCommand(new CollectDeployWithJoystick());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }
    
    public CollectorDeployer() {
        m_deployPotMinimum = 0;
        m_deployPotInterlockMinimum = 10;
        m_deployPotMaximum = 20;
        
        // The dashboard is created before the robot subsystems are constructed, so it should be ok to push the default values to the SmartDashboard now.
        SmartDashboard.putNumber("DeployPotMin", m_deployPotMinimum);
        SmartDashboard.putNumber("DeployPotMax", m_deployPotMaximum);
        SmartDashboard.putNumber("DeployPotInterlockMin", m_deployPotInterlockMinimum);
               
    }
            
    public void deployInOut(double magnitudeDirection) {
        // if we are currently at a limit, don't do anything...
        if (((magnitudeDirection >0) && reachedLimit("Max")) ||
            ((magnitudeDirection <0) && reachedLimit("Min"))) return;
        // input arg is signed value between +1 and -1 for fwd/backward speed/magnitude.
        // This function ASSUMES that forward is positive (unlike a joystick, which returns negative values for forward!)
        // Input of course does not HAVE to be a joystick-- can be a fixed value if for instance it is called by a button press...
        // If gearing inverts the desired motor direction, *THIS* is the place where it should be inverted...
        deploymentMotor.set(magnitudeDirection);
        deploymentMotor2.set(magnitudeDirection);
    }
    
    public void stop() {
        deploymentMotor.set(0);
        deploymentMotor2.set(0);
    }
    
    // This function is intended to indicate whether we have reached/exeeded a given limit.
    // This function also handles overrides from the SmartDashboard.
    // Putting all the override and min/max checks in one function makes it easier to find/modify/debug in one single place.
    // TODO:  A great improvement would be to pass the subsystem, pot, and limit in as variables and share this function across subsystems...
    public boolean reachedLimit(String limitName) {
        // The limit values we compare the pot against
        double deployPotMax;
        double deployPotMin;
        double deployPotInterlockMin;
        
        // override switches provided by the SmartDashboard
        boolean overrideMax;
        boolean overrideMin;
        boolean overrideInterlockMin;
        
        // Holds the value of the string pot that determines arm position
        int potVal;
        
        // Used to determine which limit we're testing
        boolean isMaxCheck = false;
        boolean isMinCheck = false;
        boolean isInterlockCheck = false;
        
        // Holds the final return value
        boolean result = false;
        
        // Which limit are we checking?
        if (limitName.equals("Max")) isMaxCheck = true;
        else if (limitName.equals("Min")) isMinCheck = true;
        else if (limitName.equals("Interlock")) isInterlockCheck = true;
        else System.out.println("Attempt to call Deploy reachedLimit with illegal string " + limitName);
        // If we have disabled all sensors via the masterSensorDisable in Robot.java, then immediately return an appropriate value
        if (Robot.m_masterSensorDisable)
        {
            if (isMaxCheck || isMinCheck) result = false; // False means the sensor has not detected a limit
            else if (isInterlockCheck) result = true; // True means sensor believes we are past the interlock point
            return result;
        }
        
       // Get/calculate the allowed extension values.
       // default is to use the compiled version of the limit:
       deployPotMax = m_deployPotMaximum;
       deployPotMin = m_deployPotMinimum;
       deployPotInterlockMin = m_deployPotInterlockMinimum;
       
           
        // However, allow the SmartDashboard to override these limits if needed:
        // Use any provided override instead of the compiled value (or default if not)
        deployPotMax = SmartDashboard.getNumber("DeployPotMax", m_deployPotMaximum);
        deployPotMin = SmartDashboard.getNumber("DeployPotMin", m_deployPotMinimum);
        deployPotInterlockMin = SmartDashboard.getNumber("DeployPotInterlockMin", m_deployPotInterlockMinimum);
        // Return false until a limit is reached.
        // FIXME:  return hard coded value until pot is installed
        //potVal = RobotMap.collectorDeployerExtensionStringPot.getValue();
        //System.out.println("DeployPotVal = " + potVal);
        potVal = 5; // 5 will be less than interlock, which will run until hard limit is reached instead.
        
        // Output current pot for empirical debugging; 
        //SmartDashboard.putNumber("CurrentDeployPotAvg", potAvgVal);
        
        //Get the hard limit switch values.
        // Default/unconnected = true, so we invert the incoming value of the switch
        // so that a false value from switch means "true" for our internal variable.
        // That way, if the switch gets disconnected it will look
        // like switch limit has not been hit (i.e. continue normal operation)
        boolean limitIn  = !RobotMap.collectorDeployerDeployLimitIn.get();
        boolean limitOut = !RobotMap.collectorDeployerDeployLimitOut.get();
               
        // Print Limit Switch values to Driver Station
        //System.out.print("Deploy Out Limit = ");
        //System.out.print(limitOut);
        //System.out.println("");
        
        //System.out.print("In CollectorDeployer::reachedLimit, Deploy In Limit = ");
        //System.out.println(limitIn);
        
        
        // 'Or' in the requested limit if requested (Someday we may want multiple checks)
        if (isMaxCheck) result = result || ((potVal >= deployPotMax) ||
                                   (limitOut));
        if (isMinCheck) result = result || ((potVal <= deployPotMin) ||
                                   (limitIn));
        if (isInterlockCheck) result = result || ((potVal >= deployPotInterlockMin) ||
                                          (limitOut));
        if (result) {
            //System.out.println("Deploy hit a limit:  pot = " + potVal + " MinLimit = " + limitIn + " MaxLimit = " + limitOut);
        }
        
        // Finally, do the actual limit checks and return true if one has been exceeded.
        // If you need to totally eliminate limit assertions for debug, just return false.
        return result;
    }
}
