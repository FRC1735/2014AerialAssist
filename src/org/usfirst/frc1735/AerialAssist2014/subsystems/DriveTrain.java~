// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.
package org.usfirst.frc1735.AerialAssist2014.subsystems;
import org.usfirst.frc1735.AerialAssist2014.RobotMap;
import org.usfirst.frc1735.AerialAssist2014.Robot;
import org.usfirst.frc1735.AerialAssist2014.commands.*;
import edu.wpi.first.wpilibj.*;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj.DriverStationLCD;
/**
 *
 */
public class DriveTrain extends Subsystem {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    SpeedController rightFront = RobotMap.driveTrainrightFront;
    SpeedController leftFront = RobotMap.driveTrainleftFront;
    SpeedController rightRear = RobotMap.driveTrainrightRear;
    SpeedController leftRear = RobotMap.driveTrainleftRear;
    RobotDrive robotDrive41 = RobotMap.driveTrainRobotDrive41;
    Gyro gyro1 = RobotMap.driveTrainGyro1;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    // Pointer to DriverStation user message window
    //DriverStationLCD m_DS = DriverStationLCD.getInstance();
  
    
    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        setDefaultCommand(new DriveWithJoysticks());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	
        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
        
}
    
/*  Post Southington competition, we are swapping the mecanum drive for a standard 6-wheel, drop-center tank drive.
    Adding the tankDrive variants and commenting out the mecanum drive functions as a result.
*/
    public void tankDriveWithJoysticks(Joystick left, Joystick right) {
        // Left here in case we need to display the pot value in a function that is always running...
        //double potVal = RobotMap.shooterExtensionStringPot.getValue();
        //System.out.println("potVal = " + potVal);
  
        // Collect the Joystick info.
        // We need to filter out very small joystick values and clamp them to zero
        // so that a slightly off-center joystick doesn't send signals to the motor.
        double driveLeft = left.getY();
        double driveRight = -right.getY();
        
        //Apply Filter
        if (Math.abs(driveLeft) < Robot.m_joystickFilter) {driveLeft = 0;}
        if (Math.abs(driveRight) < Robot.m_joystickFilter) {driveRight = 0;}
       
        this.tankDrive(driveLeft, driveRight);
    }
    
    // This is just a wrapper so the joystick and direct methods live in the same class for consistency.
    public void tankDrive(double driveLeft,double driveRight) {
        // The motors spin faster in one direction than the other.
        // For this robot configuration:
        //     The right side motors spin faster in the forward direction.
        //     The left side motors spin faster in the backward direction.
        // Create a compensator for this
        // Can't add to slower drive if it's already 1.0, so must subtract off faster unit.
        // Actually, we want to use a percentage rather than subtracting a factor.
        // Algo:
        // Only compensate if both values are the same (intending to track straight, or are in autonomous)
        //   if magnitude positive, reduce right side speed.
        //   if magnitude negative, reduce left  side speed.
        
        // We have some funny negative signs floating around, so be sure to use absolute values for this check
//        if (Math.abs(driveLeft) == Math.abs(driveRight)) {
//            System.out.println("Compensating for input drive magnitude Left = " + driveLeft + " Right = " + driveRight);
//            
//            double motorCompensation = SmartDashboard.getNumber("motorCompensation", .1); // a 10% default should be easy to see if we accidentally got it
//        
//            if (driveRight > 0)
//                driveRight = driveRight * motorCompensation; 
//            else
//                driveLeft  = driveLeft  * motorCompensation;
//            //in the zero case, no compensation needed.
//        }
//        // Drive with the compensated value.
//        System.out.println("After Compensation Left = " + driveLeft + " Right = " + driveRight);
        robotDrive41.tankDrive(driveLeft, driveRight);
    }
  
//    public void mecanumDriveWithJoysticks(Joystick drive, Joystick rotate) {
//        double gyroAngle = gyro1.getAngle();
//        
//        // Display angle to SmartDashboard
//        SmartDashboard.putNumber("Gyro Angle", gyroAngle);
//        
//        // Just for grins, try printing it to a place on the DriverStation:
//        // Args are line, column (1-based), string.
//        //m_DS.println(DriverStationLCD.Line.kUser1, 1, "Gyro Angle = " + gyroAngle);
//        
//        double potVal = RobotMap.shooterExtensionStringPot.getValue();
//        //System.out.println("potVal = " + potVal);
//
//        // Collect the Joystick info.
//        // We need to filter out very small joystick values and clamp them to zero
//        // so that a slightly off-center joystick doesn't send signals to the motor.
//        double driveX = drive.getX();
//        double driveY = drive.getY();
//        double rotateX = rotate.getX();
//        
//        //Apply Filter
//        if (Math.abs(driveX) < Robot.m_joystickFilter) {driveX = 0;}
//        if (Math.abs(driveY) < Robot.m_joystickFilter) {driveY = 0;}
//        if (Math.abs(rotateX) < Robot.m_joystickFilter) {rotateX = 0;}
//       
//        robotDrive41.mecanumDrive_Cartesian(-driveX, -driveY, -rotateX, gyroAngle);
//        
//        // FYI, the rangefinder is polled and displays distance info to the SmartDashboard and DriverStation in Range.java.
//    }   
//    
//    public void mecanumDriveCartesian(double driveX,double driveY) {
//          double gyroAngle = gyro1.getAngle();
//          robotDrive41.mecanumDrive_Cartesian(-driveX, driveY, 0, gyroAngle);
//    }
    
    public void stop() {
        robotDrive41.drive(0, 0); // magnitude, curve
    }
}
