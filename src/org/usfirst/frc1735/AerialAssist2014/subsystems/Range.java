// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.
package org.usfirst.frc1735.AerialAssist2014.subsystems;
import org.usfirst.frc1735.AerialAssist2014.RobotMap;
import org.usfirst.frc1735.AerialAssist2014.commands.*;
import edu.wpi.first.wpilibj.*;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
/**
 *
 */
public class Range extends Subsystem {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    AnalogChannel ultrasonicRange = RobotMap.rangeUltrasonicRange;
    Relay shotLightRelay = RobotMap.rangeShotLightRelay;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    // Member variables
    double m_shotMaxRange; // maximum distance from wall where we can make a successful shot
    double m_shotMinRange; // minimum distance from wall where we can make a successful shot
    
    // Pointer to DriverStation user message window
    //DriverStationLCD m_DS = DriverStationLCD.getInstance();
    public Range() {
        // initialize our ranges.
        m_shotMinRange = 6;
        m_shotMaxRange = 9;
        shotLightRelay.setDirection(Relay.Direction.kForward); // set only one direction to avoid reverse-biasing the circuit and destroying it.
    }
    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	
        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }
    
    //function to convert analog voltages to distance
    public double getDistance() {
        double rangeVoltage = ultrasonicRange.getAverageVoltage();
        // Distance scaling factor is VCC/512 per inch.
        // At 5v input, that is 9.8mV/in.
        // Calculate distance(in ft) = voltage/.0098/12
        return rangeVoltage/.0098/12;
    }
    
    // Returns true if we are between the min and max settings for successful shots into the goal
    // This is polled by the ControlShotLight command that is invoked at start of autonomous/teleop (see Robot.java)
    public boolean inShotRange() {
        // Get the rangefinder value, given in feet.
        double currentDistance = getDistance();
        
        // Print current value to the Smart Dashboard *and* to the DriverStation.
        SmartDashboard.putNumber("Distance (ft)", currentDistance);
        //m_DS.println(DriverStationLCD.Line.kUser2, 1, "Distance (ft) = " + currentDistance);
        ///System.out.println("Distance = " + currentDistance);
        // to minimize LCD updates, the calling command thread does the update.
        return ((currentDistance <= m_shotMaxRange) &&
                (currentDistance >= m_shotMinRange));
    }
    
    //control the relay and also print a message to the DriverStation:
    public void shotLightEnable (boolean enable_me) {
        // Print status to Smart Dashboard:
        SmartDashboard.putBoolean("In Range", enable_me);
            
        if (enable_me) {
            shotLightRelay.set(Relay.Value.kOn); // Might need kForward?  If Direction is set to kForward, this should be sufficient/correct.
            // Print status to the DriverStation:
            //m_DS.println(DriverStationLCD.Line.kUser3, 1, "***IN RANGE***");
            
        }
        else {
            shotLightRelay.set(Relay.Value.kOff);
            // Clear out the status indication on the DriverStation:
            //m_DS.println(DriverStationLCD.Line.kUser3, 1, "              ");
                    
        }
        // to minimize LCD updates, the calling command thread does the update.            
    }
}
