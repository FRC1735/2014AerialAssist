// RobotBuilder Version: 1.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.
package org.usfirst.frc1735.AerialAssist2014.subsystems;
import org.usfirst.frc1735.AerialAssist2014.RobotMap;
import org.usfirst.frc1735.AerialAssist2014.commands.*;
import edu.wpi.first.wpilibj.*;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import org.usfirst.frc1735.AerialAssist2014.Robot;
/**
 *
 */
public class Shooter extends Subsystem {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    SpeedController catapultMotor = RobotMap.shooterCatapultMotor;
    SpeedController catapultMotor2 = RobotMap.shooterCatapultMotor2;
    SpeedController catapultMotor3 = RobotMap.shooterCatapultMotor3;
    AnalogChannel extensionStringPot = RobotMap.shooterExtensionStringPot;
    DigitalInput shooterExtendLimit = RobotMap.shooterShooterExtendLimit;
    DigitalInput shooterReturnLimit = RobotMap.shooterShooterReturnLimit;
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    // Member Variables
    public double m_shootPotMinimum; // Minimum pot reading to be considered fully retracted
    public double m_shootPotMaximum; // Maximum pot reading to be considered fully extended
    public double m_requestedPotMax; // user-requested value for the shoot pot maximum (supports variable-angle shots)
    public boolean m_requestMaxOverride; // flag that qualifies the use of the above variable for shot angle.
    
    boolean m_ignoreInitialLimitCheck;   
    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        setDefaultCommand(new ShootStop());
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	
        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }
    
    public Shooter() {
        // pot is backwards.  smaller values as we approach max extension.
        m_shootPotMinimum = 534; // absolute Min at 917
        m_shootPotMaximum = 175; // Absolute Max at 125
        m_ignoreInitialLimitCheck = false;
        m_requestMaxOverride = false; // Assume we aren't using a variable angle request
        m_requestedPotMax = m_shootPotMaximum; // default to the hard-coded value for backwards compatibility
        
        // The dashboard is created before the robot subsystems are constructed, so it should be ok to push the default values to the SmartDashboard now.
        //SmartDashboard.putNumber("ShootPotMin", m_shootPotMinimum);
        //SmartDashboard.putNumber("ShootPotMax", m_shootPotMaximum);
        //SmartDashboard.putBoolean("OverrideShootPotMin", false);
        //SmartDashboard.putBoolean("OverrideShootPotMax", false);
    }
    
    public void ReallyReallyShootInOut(double magnitudeDirection) {
        //set a var to ignore the "limit already reached" check
        m_ignoreInitialLimitCheck = true;
        ShootInOut(magnitudeDirection);
        m_ignoreInitialLimitCheck = false; // return to default state
    }
    public void ShootInOut(double magnitudeDirection) {
        // if we are currently at a limit, don't do anything...
        if (!m_ignoreInitialLimitCheck) {
            if (((magnitudeDirection >0) && reachedLimit("Max")) ||
                ((magnitudeDirection <0) && reachedLimit("Min"))) return;
        }
        
        // *****************
        // *** IMPORTANT ***
        // *****************
        // You don't want to move the shooter if the collector is stowed and in the way.
        // ROBOT DAMAGE MAY RESULT!!!!!
        
        // Shooter should always extend the collector before moving (in either direction)
        // by calling the command GROUP "DeployThenShoot" or "DeployThenRetractShooter".
        // Those functions guarantee collector deployment before issuing a command that calls the current function we're in.
        // The following is just a last ditch sanity check in case the call stack directly calls this function with a nonzero value.
        ///if ((magnitudeDirection != 0) && !Robot.collectorDeployer.reachedLimit("Interlock"))
        ///    System.out.println("ERROR:  Attempt to call the shooter with collector not deployed!!!");
        ///else {
            // input arg is signed value between +1 and -1 for fwd/backward speed/magnitude.
            // This function ASSUMES that forward is positive (unlike a joystick, which returns negative values for forward!)
            // Input of course does not HAVE to be a joystick-- can be a fixed value if for instance it is called by a button press...
            // If gearing inverts the desired motor direction, *THIS* is the place where it should be inverted...
            catapultMotor.set(magnitudeDirection);
            catapultMotor2.set(magnitudeDirection);
            catapultMotor3.set(magnitudeDirection);
        ///}
    }
    
    public void stop() {
        catapultMotor.set(0);
        catapultMotor2.set(0);
        catapultMotor3.set(0);
    }
    
    // Accessor function for setting a requested shootpot max (for variable angle shooting)
    public void setPotMax(double maxVal) {
        m_requestedPotMax = maxVal;
    }
    
    // Set/clear a flag that enables use of the ShootPotMax value for variable angle shooting.
    // User must set this before the call to ReachedLimit, and clear afterwards if you want to use the default full strength (from other functions).
    public void setPotMaxRequest() {
            m_requestMaxOverride = true;
    }
    public void clearPotMaxRequest() {
            m_requestMaxOverride = false;
    }
    
    // This function is intended to indicate whether we have reached/exeeded a given limit.
    // This function also handles overrides from the SmartDashboard.
    // Putting all the override and min/max checks in one function makes it easier to find/modify/debug in one single place.
    // TODO:  A great improvement would be to pass the subsystem, pot, and limit in as variables and share this function across subsystems...
    public boolean reachedLimit(String limitName) {
        // The limit values we compare the pot against
        double shootPotMax;
        double shootPotMin;
        
        // override switches provided by the SmartDashboard
        boolean overrideMax;
        boolean overrideMin;
        
        // Holds the value of the string pot that determines arm position
        int potVal;
        
        // Used to determine which limit we're testing
        boolean isMaxCheck = false;
        boolean isMinCheck = false;
        
        // Holds the final return value
        boolean result;
        // Which limit are we checking?
        if (limitName.equals("Max")) isMaxCheck = true;
        else if (limitName.equals("Min")) isMinCheck = true;
        else System.out.println("Attempt to call shooter reachedLimit with illegal string " + limitName);
    
       // If we have disabled all sensors via the masterSensorDisable in Robot.java, then immediately return false (i.e. no limit has been reached)
        if (Robot.m_masterSensorDisable)
            return false;
        
       // Get/calculate the allowed extension values.
       // default is to use the compiled version of the limit:
       shootPotMax = m_shootPotMaximum;
       shootPotMin = m_shootPotMinimum;
       
        // New feature:  user can request a pot value (vor variable shot angle).
        // treat this like an override-- if the user sets the "I'm making a request" flag, then use the value.
        // Implemented as a separate flag to avoid perturbing the existing code too much before STL competition
        if (m_requestMaxOverride) {
                shootPotMax = m_requestedPotMax;
        }
       
        // However, allow the SmartDashboard to override any of these limits if needed:
        overrideMax = SmartDashboard.getBoolean("OverrideShootPotMax", false);
        if (overrideMax) {
            // If override button set, use the provided override instead of the compiled value
            shootPotMax = SmartDashboard.getNumber("ShootPotMax");
        }
        
        overrideMin = SmartDashboard.getBoolean("OverrideShootPotMin", false);
        if (overrideMin) {
            // If override button set, use the provided override instead of the compiled value
            shootPotMin = SmartDashboard.getNumber("ShootPotMin");
        }
        // Return false until a limit is reached.
        potVal = RobotMap.shooterExtensionStringPot.getValue();
        //System.out.println("potVal = " + potVal);
        //potVal = 4;
        
        // Output current pot for empirical debugging; 
        //SmartDashboard.putNumber("CurrentShootPotAvg", potVal);
        
        result = false;
        // 'Or' in the requested limit if requested (Someday we may want multiple checks)
        
        //Get the hard limit switch values.
        // Default/unconnected = true, so we invert the incoming value of the switch
        // so that a false value from switch means "true" for our internal variable.
        // That way, if the switch gets disconnected it will look
        // like switch limit has not been hit (i.e. continue normal operation)
boolean hardLimitVal;
        if (isMaxCheck) {
            // our var is true=switch closed; sensor reports true=switch open, so invert.
            hardLimitVal = !shooterExtendLimit.get();
            if (Robot.m_masterSensorDisable) hardLimitVal = false;
            // Pot is wired so that longer lengths are smaller values.  Sigh.
            // So the max check is when it's LESS than the max limit value.
            result = result || ((potVal <= shootPotMax) ||
                                    hardLimitVal);
            // In practice shots, it was hard to tell which limit we were hitting.  Add a helpful print message:
            if (result) {
                if (potVal <= shootPotMax)
                    System.out.println("Shooter MaxCheck was hit:  Pot = " + (potVal <= shootPotMax) + " Limit = " + hardLimitVal);                                       
            }
        }
        if (isMinCheck) {
            hardLimitVal = !shooterReturnLimit.get();
            if (Robot.m_masterSensorDisable) hardLimitVal = false;
            // Pot is wired so that longer lengths are smaller values.  Sigh.
            // So the min check is when it's GREATER than the min limit value.
            result = result || ((potVal >= shootPotMin) ||
                                    hardLimitVal);
        }
        
        // Finally, do the actual limit checks and return true if one has been exceeded.
        return result;
    }
    
}
